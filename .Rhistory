# Transformar tibble em SpatVector (definindo x e y como coordenadas)
sites <- vect(as.data.frame(d13.amz), geom = c("x", "y"), crs = "EPSG:4674")
#Retirando coordenadas
d13.amz <- d13.amz %>% dplyr::select(-x, -y, -Site, -Family)
#Definindo a variável resposta e covariáveis
resposta <- d13.amz$d13C_wood
#Preditoras
preditoras <- d13.amz%>% dplyr::select(-d13C_wood)
#Checando valores ausentes
if (anyNA(preditoras)) {
cat("Warning: Missing values found in predictors. Please handle them before proceeding.\n")
print(which(is.na(predictors), arr.ind = TRUE))
} else {
cat("No missing values found in predictors.\n")
}
#Nome da variável preditora
pred.names<- names(preditoras)
#Definindo a formula do modelo de regressão
formula_rf1 <- as.formula(paste("d13C_wood ~", paste(pred.names, collapse = " + ")))
formula_rf1
#Modelo RF com o pacotes ramdomForest
#Fixando a reprodutibilidade
set_reproducibility()
rf.mod1  <- randomForest(
formula_rf1,
data = d13.amz,
ntree = 2000,
importance = TRUE,
keep.forest = TRUE
)
rf.mod1  <- randomForest(
formula_rf1,
data = d13.amz,
ntree = 2000,
importance = TRUE,
keep.forest = TRUE
)
rf.mod1
#Modelo RF com o pacotes ramdomForest
#Fixando a reprodutibilidade
set_reproducibility()
rf.mod1  <- randomForest(
formula_rf1,
data = d13.amz,
ntree = 2000,
importance = TRUE,
keep.forest = TRUE
)
#Modelo RF com o pacotes ramdomForest
#Fixando a reprodutibilidade
set_reproducibility()
rf.mod1  <- randomForest(
formula_rf1,
data = d13.amz,
ntree = 2000,
importance = TRUE,
keep.forest = TRUE
)
rf.mod1
# Criar um data frame com Observado e Predito
dados_plot <- data.frame(
Observado = d13.amz$d13C_wood,
Predito = rf.mod1$predicted
)
# Plotar com ggplot2
ggplot(dados_plot, aes(x = Observado, y = Predito)) +
geom_point(shape = 21, fill = "white", size = 3, color = "black") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", size = 1) +
labs(
x = expression("Mensurado "*delta^{13}*"C"["Madeira"]),
y = expression("Predito "*delta^{13}*"C"["Madeira"])
) +
theme_bw() +
theme(
axis.title = element_text(size = 14),
axis.text = element_text(size = 12))
# Convertendo as variáveis preditoras para o formato matricial (requirido pelo VSURF)
preditoras_matrix <- as.matrix(preditoras)
# Rodando VSURF para seleção de variáveis
# Fixando a reprodutibilidade
set_reproducibility()
vsurf_result <- VSURF::VSURF(preditoras_matrix, resposta,
ntree = 500,
nfor.thres = 20,
nfor.interp = 100,
nfor.pred = 10,
nsd = 1,
parallel = FALSE,
verbose=FALSE)
#Extração das variáveis selecionadas VSURF
threshold_vars <- names(preditoras)[vsurf_result$varselect.thres]
interp_vars    <- names(preditoras)[vsurf_result$varselect.interp]
interp_vars    <- names(preditoras)[vsurf_result$varselect.interp]
pred_vars      <- names(preditoras)[vsurf_result$varselect.pred]
#Print das variáveis
cat("\nVariaveis selecionadas (Threshold):\n")
print(threshold_vars)
cat("nVariaveis selecionadas (Interpretação):\n")
cat("nVariaveis selecionadas (Interpretação):\n")
print(interp_vars)
cat("nVariaveis selecionadas (Predição):\n")
print(pred_vars)
#Construindo a formula
formula_rf2 <- as.formula(paste("d13C_wood ~", paste(pred_vars, collapse = " + ")))
formula_rf2
#Fixando a reprodutibidade
set_reproducibility()
rf.mod2 <- randomForest(
formula_rf2,
data = d13.amz,
ntree = 2000,
importance = TRUE,
keep.forest = TRUE
)
#Fixando a reprodutibidade
set_reproducibility()
rf.mod2 <- randomForest(
formula_rf2,
data = d13.amz,
ntree = 2000,
importance = TRUE,
keep.forest = TRUE
)
rf.mod2
#Plot error OOB  vs número de árvores
plot(rf.mod2, main = "OOB Error vs Number of Trees")
rf.tune <- caret::train(formula_rf2,
data = d13.amz,
ntree = 500)
rf.tune$results
rf.tune$results
rf.tune$bestTune
# Fixando a reprodutibilidade
set_reproducibility()
partition <- caret::createDataPartition(d13.amz$d13C_wood, p = 0.8, list = FALSE)
treino <- d13.amz[partition, ]
treino <- d13.amz[partition, ]
teste <- d13.amz[-partition, ]
# AJustando o modelo com dados de treino
rf.train <-  randomForest(formula_rf2, data = treino, ntree = 500)
rf.train
# Data frame Observado x Predito
dados_plot2 <- data.frame(
Observado = teste$d13C_wood,
Predito = predict(rf.train, teste)
)
# Calcular MSE
MSE_value <- mean((dados_plot2$Predito - dados_plot2$Observado)^2)
MSE_value
MSE_value
# Calcular R2
R2_value<- (cor(dados_plot2$Observado, dados_plot2$Predito))^2
R2_value
R2_value
# ggplot com anotação
ggplot(dados_plot2, aes(x = Observado, y = Predito)) +
geom_point(shape = 21, fill = "white", size = 3, color = "black") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", size = 1.2) +
labs(
x = expression("Mensurado "*delta^{13}*"C"["Madeira"]),
y = expression("Predito "*delta^{13}*"C"["Madeira"])
) +
annotate("text",
x = min(dados_plot$Observado) + 0.95 * diff(range(dados_plot$Observado)),
y = min(dados_plot$Predito) + 0.05 * diff(range(dados_plot$Predito)),
label = paste0("MSE = ", round(MSE_value, 2)),
hjust = 1, vjust = 0, size = 5) +
annotate("text",
x = min(dados_plot$Observado) + 0.95 * diff(range(dados_plot$Observado)),
y = min(dados_plot$Predito) + 0.2 * diff(range(dados_plot$Predito)),
label = paste0("R2 = ", round(R2_value, 2)),
hjust = 1, vjust = 0, size = 5) +
theme_bw() +
theme(
axis.title = element_text(size = 14),
axis.text = element_text(size = 12)
)
rf.train
# Calcular MSE
MSE_value <- mean((dados_plot2$Predito - dados_plot2$Observado)^2)
MSE_value
# Calcular R2
R2_value<- (cor(dados_plot2$Observado, dados_plot2$Predito))^2
R2_value
R2_value
# ggplot com anotação
ggplot(dados_plot2, aes(x = Observado, y = Predito)) +
geom_point(shape = 21, fill = "white", size = 3, color = "black") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", size = 1.2) +
labs(
x = expression("Mensurado "*delta^{13}*"C"["Madeira"]),
y = expression("Predito "*delta^{13}*"C"["Madeira"])
) +
annotate("text",
x = min(dados_plot$Observado) + 0.95 * diff(range(dados_plot$Observado)),
y = min(dados_plot$Predito) + 0.05 * diff(range(dados_plot$Predito)),
label = paste0("MSE = ", round(MSE_value, 2)),
hjust = 1, vjust = 0, size = 5) +
annotate("text",
x = min(dados_plot$Observado) + 0.95 * diff(range(dados_plot$Observado)),
y = min(dados_plot$Predito) + 0.2 * diff(range(dados_plot$Predito)),
label = paste0("R2 = ", round(R2_value, 2)),
hjust = 1, vjust = 0, size = 5) +
theme_bw() +
theme(
axis.title = element_text(size = 14),
axis.text = element_text(size = 12)
)
# Leave-Group-Out CV (também conhecido como Monte Carlo CV).
fitControl <- caret::trainControl(method = "LGOCV", number = 10, p = 0.8)
# Fixando a reprodutibidade
set_reproducibility()
rf.mod3 <-caret::train(formula_rf2,
data= d13.amz, method="rf",
trControl=fitControl)
# Fixando a reprodutibidade
set_reproducibility()
rf.mod3 <-caret::train(formula_rf2,
data= d13.amz, method="rf",
trControl=fitControl)
rf.mod3$resample
rf.mod3
rf.mod3
varImpPlot(rf.mod3$finalModel,main='Variable Importance Plot: Base Model')
varImpPlot(rf.mod3$finalModel,main='Variable Importance Plot: Base Model')
imp<-varImp(rf.mod3$finalModel)
varImpPlot(rf.mod3$finalModel,main='Variable Importance Plot: Base Model')
imp<-varImp(rf.mod3$finalModel)
imp$varnames <- rownames(imp) # row names to column
rownames(imp) <- NULL
rownames(imp) <- NULL
imp
varimport<-ggplot(imp, aes(x=reorder(varnames, Overall), y=Overall)) +
geom_point() +
geom_segment(aes(x=varnames,xend=varnames,y=0,yend=Overall)) +
ylab("%IncMSE") +
xlab("Variable Name") +
coord_flip()+
theme_bw()+
theme(panel.grid = element_blank(),axis.title = element_text(size = 14),axis.text = element_text(size = 12))
varimport
# Listar todos os arquivos raster na pasta 'raster/'
raster_files <- list.files(path = here("raster"), pattern = '\\.tif$', full.names = TRUE)
# Carregar todos os rasters em uma lista
# terra ->> para carregar cada arquivo raster
raster_list <- lapply(raster_files, terra::rast)
raster_list
# Empilhar os rasters em um único objeto SpatRaster
# terra ->> para empilhar todos os rasters em um único objeto
r_stack <- terra::rast(raster_list)
# Verificar os nomes dos rasters
names(r_stack) <- basename(raster_files) %>% tools::file_path_sans_ext()
print(names(r_stack))
class(r_stack)
#Predição
isoscape <- terra::predict(r_stack, rf.mod3, na.rm = TRUE)
# Carregar todos os rasters em uma lista
# terra ->> para carregar cada arquivo raster
raster_list <- lapply(raster_files, terra::rast)
raster_list
#Predição
isoscape <- terra::predict(r_stack, rf.mod3, na.rm = TRUE)
#Predição
isoscape <- terra::predict(r_stack, rf.mod3, na.rm = TRUE)
# Usando o pacote "ranger".
# Set reproducibility
set_reproducibility()
mod.qrf <- ranger::ranger(formula_rf2, data=d13.amz, num.trees = 500, quantreg = TRUE)
mod.qrf <- ranger::ranger(formula_rf2, data=d13.amz, num.trees = 500, quantreg = TRUE)
mod.qrf
#Quantis
isoscape$ci.16 <- terra::predict(r_stack, mod.qrf, type = "quantiles", quantiles = 0.16,
na.rm = TRUE)
isoscape$ci.84 <- terra::predict(r_stack, mod.qrf, type = "quantiles", quantiles = 0.84,
na.rm = TRUE)
isoscape$ci.84 <- terra::predict(r_stack, mod.qrf, type = "quantiles", quantiles = 0.84,
na.rm = TRUE)
#SD
isoscape$sd <- (isoscape$ci.84 - isoscape$ci.16) / 1.349
# Verificar e criar diretório para salvar os rasters, se não existir
if (!dir.exists(here("isoscape"))) dir.create(here("isoscape"))
#Exportando raster
isoscape.d13c <- c(isoscape$lyr1, isoscape$sd)
terra::writeRaster(isoscape.d13c, filename = here("isoscape", "isoscape_dc13.tif"), overwrite = TRUE)
# Visualizar a isoscape
terra::plot(isoscape[[1]], main = "δ13C")
# Visualizar a isoscape
terra::plot(isoscape[[1]], main = "δ13C")
# Adicionar os pontos amostrais
points(sites, pch = 21, bg = "yellow", cex = 0.8)
# Visualizar a isoscape
terra::plot(isoscape$sd, main = "SD")
# Adicionar os pontos amostrais
points(sites, pch = 21, bg = "yellow", cex = 0.8)
# Baixando temperatura média global com resolução de 10 minutos
tavg_mundo <- geodata::worldclim_global(var = "prec", res = 5, path = here("worldclim"))
print(class(tavg_mundo))
print(terra::crs(tavg_mundo))
# 1. Carregar shapefile da Amazônia Legal
amz <- terra::vect(here::here("shapefiles", "amazonia_legal.shp"))
# 2. Recortar o raster (usa o bounding box)
tavg_crop <- terra::crop(tavg_mundo, amz)
# 3. Aplicar máscara para manter apenas os pixels dentro do shape
tavg_amz <- terra::mask(tavg_crop, amz)
# 4. Visualizar um dos meses (exemplo: janeiro)
terra::plot(tavg_amz[[1]], main = "Janeiro")
# 4. Visualizar um dos meses (exemplo: janeiro)
terra::plot(tavg_amz[[12]], main = "Janeiro")
# Baixando temperatura média global com resolução de 10 minutos
tavg_mundo <- geodata::worldclim_global(var = "tavg", res = 5, path = here("worldclim"))
print(class(tavg_mundo))
print(terra::crs(tavg_mundo))
# 1. Carregar shapefile da Amazônia Legal
amz <- terra::vect(here::here("shapefiles", "amazonia_legal.shp"))
# 2. Recortar o raster (usa o bounding box)
tavg_crop <- terra::crop(tavg_mundo, amz)
# 3. Aplicar máscara para manter apenas os pixels dentro do shape
tavg_amz <- terra::mask(tavg_crop, amz)
# 4. Visualizar um dos meses (exemplo: janeiro)
terra::plot(tavg_amz[[1]], main = "Janeiro")
# Reprojetar e calcular média
tavg_amz_sirgas <- terra::project(tavg_amz, "EPSG:4674")
View(tavg_crop)
sum(tavg_amz_sirgas)/12
tavg_mean <- terra::app(tavg_amz_sirgas, mean)
# Visualizar e salvar resultado
terra::plot(tavg_mean, main = "Temperatura Média")
# Criar a pasta 'raster' na raiz do projeto
if (!dir.exists(here("raster"))) dir.create(here("raster"))
# Salvar o raster dentro da pasta 'raster'
terra::writeRaster(tavg_mean, filename = here("raster", "tavg_mean.tif"), overwrite = TRUE)
# Limpar área de trabalho
rm(list = ls())
gc(reset = TRUE)
graphics.off()
#Pacotes necessários
if(!require(readxl))install.packages("readxl", dep = TRUE)
if(!require(tidyverse))install.packages("tidyverse", dep = TRUE)
if(!require(terra))install.packages("terra", dep = TRUE)
if(!require(tidyverse))install.packages("tidyverse", dep = TRUE)
if(!require(terra))install.packages("terra", dep = TRUE)
if(!require(geodata))install.packages("geodata", dep = TRUE)
if(!require(geobr))install.packages("geobr", dep = TRUE)
if(!require(sf))install.packages("sf", dep = TRUE)
if(!require(sp))install.packages("sp", dep = TRUE)
if(!require(here))install.packages("here", dep = TRUE)
if(!require(assignR))install.packages("assignR", dep = TRUE)
if(!require(viridis))install.packages("viridis", dep = TRUE)
# 1) Ler o shapefile das UFs (Amazônia Legal)
fu <- terra::vect(here::here("shapefiles", "fu.shp"))
fu <- terra::project(fu, "EPSG:4674")
crs(fu)
fu.names <- c("Amazonas", "Mato Grosso")
fu.names <- c("Amazonas", "Mato Grosso")
fus <- fu[fu$ADM1_PT %in% fu.names]
# 2) Ler isoscape gerada pelo modelo RF
iso_files <- list.files(path = here::here("isoscape"), pattern = "\\.tif$", full.names = TRUE)
iso_d13   <- terra::rast(iso_files)
# Conferir CRS
crs(fu)
crs(iso_d13)
same.crs(fu, iso_d13)
fus.mu <- extract(iso_d13[[1]], fus, "mean", na.rm = TRUE)
fus.mu <- extract(iso_d13[[1]], fus, "mean", na.rm = TRUE)
fus.mu$ID = fu.names
fus.mu
29.31-28.34
amz_var_clim <- readxl::read_excel(here::here("dados", "madeira_amz_var_clim.xlsx"), sheet = 1)
head(amz_var_clim) #leitura das primeiras 6 linhas
head(amz_var_clim) #leitura das primeiras 6 linhas
str(amz_var_clim) #Estrutura dos dados
#Tratando NAs
d13.amz <- amz_var_clim[!is.na(amz_var_clim$d13C_wood), ]
# Adicionando ID
d13.amz$ID <- 1:nrow(d13.amz)
d13.amz <- d13.amz %>% relocate(ID, .before = 1)
unknown <- d13.amz[d13.amz$ID== 103,]
unknown <- d13.amz[d13.amz$ID== 103,]
unknown$d13C_wood
fus.mu$inv.diff <- 1 / abs(unknown$d13C_wood - fus.mu[, 2])
fus.mu$inv.diff <- 1 / abs(unknown$d13C_wood - fus.mu[, 2])
fus.mu
```{r fuDist}
#| fig-width: 6
#| fig-height: 4
cols = viridis(2, begin = 0.2, end = 0.8)
cols = viridis(2, begin = 0.2, end = 0.8)
fus.all = extract(iso_d13, fus)
d1 = density(fus.all[fus.all$ID == 1, 2], na.rm = TRUE)
fus.all = extract(iso_d13, fus)
d1 = density(fus.all[fus.all$ID == 1, 2], na.rm = TRUE)
d2 = density(fus.all[fus.all$ID == 2, 2], na.rm = TRUE)
plot(d1, xlim = range(fus.all[, 2], na.rm = TRUE),
ylim = range(c(d1$y, d2$y)), main = "",
xlab = expression(delta^{13}*"C"["wood"]), col = cols[1], lwd = 3)
lines(d2, col = cols[2], lwd = 3)
abline(v = unknown$d13C_wood, lwd = 3, lty = 3)
cols = viridis(2, begin = 0.2, end = 0.8)
fus.all = extract(iso_d13, fus)
d1 = density(fus.all[fus.all$ID == 1, 2], na.rm = TRUE)
d2 = density(fus.all[fus.all$ID == 2, 2], na.rm = TRUE)
plot(d1, xlim = range(fus.all[, 2], na.rm = TRUE),
ylim = range(c(d1$y, d2$y)), main = "",
xlab = expression(delta^{13}*"C"["wood"]), col = cols[1], lwd = 3)
lines(d2, col = cols[2], lwd = 3)
abline(v = unknown$d13C_wood, lwd = 3, lty = 3)
legend("topleft", fu.names, lwd = 3, col = cols, bty = "n")
p1 <- d1$y[which.min(abs(unknown$d13C_wood - d1$x))]
p1 <- d1$y[which.min(abs(unknown$d13C_wood - d1$x))]
p2 <- d2$y[which.min(abs(unknown$d13C_wood - d2$x))]
cat("PD Amazonas = ", p1, "\nPD Mato Grosso = ", p2, "\nRatio = ", p1 / p2)
data.frame("Region" = fu.names, "Posterior_probability" =
c(p1 / sum(p1, p2), p2 / sum(p1, p2)))
sum(!is.na(values(iso_d13[[1]])))
1 / sum(!is.na(values(iso_d13[[1]])))
unknown$d13C_wood
sam <- data.frame("ID" = unknown$ID, "d13C" = unknown$d13C_wood)
sam <- data.frame("ID" = unknown$ID, "d13C" = unknown$d13C_wood)
p.map1 <-  pdRaster(iso_d13, sam, genplot = FALSE)
uk.sp <- vect(unknown, geom = c("x", "y"), crs = "EPSG:4674")
fu.sub <- fu[fu$ADM1_PT %in% fu.names]
plot(p.map1, axes = FALSE)
lines(fu.sub, lwd = 2)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 2, lwd = 2, bg = "white")
0.000080/100
0.000080*100
extract(p.map1, uk.sp)
3.786974e-05*100
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
plot(qt1, axes = FALSE)
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
plot(qt1, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 2, lwd = 2, bg = "white")
qt2<-qtlRaster(p.map1, 0.05, thresholdType = "prob", genplot = FALSE)
plot(qt2, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 1.5, lwd = 2, bg = "white")
extract(qt2, uk.sp)
qt2<-qtlRaster(p.map1, 0.95, thresholdType = "prob", genplot = FALSE)
plot(qt2, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 1.5, lwd = 2)
extract(qt2, uk.sp)
oddsRatio(p.map1, fu.sub)
pts = sample(which(fus.all$ID == 1), 5)
pts = c(pts, sample(which(fus.all$ID == 2), 5))
plot(NULL, xlim = c(-32, -26), ylim = c(0, 0.5),
xlab = expression(delta^{13}*"C"["wood"]), ylab = "Density")
for(i in pts){
lines(density(rnorm(1e6, fus.all[i, 2], fus.all[i, 3])), lwd = 3,
col = cols[fus.all[i, 1]])
}
abline(v = unknown$d13C_wood, lwd = 3, lty = 3)
legend("topleft", fu.names, lwd = 3, col = cols, bty = "n")
pts = sample(which(fus.all$ID == 1), 5)
pts = c(pts, sample(which(fus.all$ID == 2), 5))
plot(NULL, xlim = c(-32, -26), ylim = c(0, 0.7),
xlab = expression(delta^{13}*"C"["wood"]), ylab = "Density")
for(i in pts){
lines(density(rnorm(1e6, fus.all[i, 2], fus.all[i, 3])), lwd = 3,
col = cols[fus.all[i, 1]])
}
abline(v = unknown$d13C_wood, lwd = 3, lty = 3)
legend("topleft", fu.names, lwd = 3, col = cols, bty = "n")
plot(density(d13.amz$d13C_wood[d13.amz$Family == unknown$Family &
d13.amz$Site == unknown$Site]),
xlab = expression(delta^{13}*"C"["wood"]), main = "", lwd = 2)
known = d13.amz[d13.amz$Family == "Burseraceae", c("x", "y", "d13C_wood")]
known = vect(known, geom = c("x", "y"), crs = "EPSG:4674")
qa1 = QA(known, iso_d13, bySite = FALSE, recal = FALSE)
plot(qa1)
qt1 <- qtlRaster(p.map1, 0.95, genplot = FALSE)
qt1 <- qtlRaster(p.map1, 0.95, genplot = FALSE)
plot(qt1, axes = FALSE)
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
plot(qt1, axes = FALSE)
lines(fu.sub)
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
plot(qt1, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 2, lwd = 2, bg = "white")
qt1 <- qtlRaster(p.map1, 0.95, genplot = FALSE)
plot(qt1, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 2, lwd = 2, bg = "white")
qt1 <- qtlRaster(p.map1, 0.5, genplot = FALSE)
plot(qt1, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 2, lwd = 2, bg = "white")
qt2<-qtlRaster(p.map1, 0.5, thresholdType = "prob", genplot = FALSE)
plot(qt2, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 1.5, lwd = 2)
extract(qt2, uk.sp)
qt2<-qtlRaster(p.map1, 0.95, thresholdType = "prob", genplot = FALSE)
plot(qt2, axes = FALSE)
lines(fu.sub)
#lines(brazil, lwd = 2)
points(uk.sp, pch = 21, cex = 1.5, lwd = 2)
extract(qt2, uk.sp)
